Object subclass: #OOPObject	instanceVariableNames: 'superclassInstances'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP4'!!OOPObject methodsFor: 'as yet unclassified' stamp: 'n 6/17/2018 17:40'!definingInstance: aSymbol  |tmp|
"will count the number of appearences of aSymbol, reguardless of protection levels"(((self class) isAmbiguos: aSymbol) > 1) ifTrue:[ ^nil]. "if it does not even appear we can know already that it is undefined"(((self class) isAmbiguos: aSymbol) = 0) ifTrue:[ ^nil]."----------here we know that there is only ONE instance of the method---------""we return inaccsible if one of the father  anccestors has private in the way for the look up for the method "((self class)  isInaccessible: aSymbol) ifTrue:[ ^nil]."we find which class contains our method , there must be one according to our checks above "tmp := (self class) findClassThatContains: aSymbol." we search which instance and we return it "^(self findInstance: tmp).! !!OOPObject methodsFor: 'as yet unclassified' stamp: 'bw 6/18/2018 17:14'!doesNotUnderstand: aMessage|classWhoSentTheMessage aSymbol protectionLevel|classWhoSentTheMessage:= thisContext client class .aSymbol := aMessage selector. protectionLevel := self class classifyInheritedMethod: aSymbol."if public run it"protectionLevel = 'public' ifTrue: [	"run method"	(self definingInstance: aSymbol) perform: aSymbol.
 	^self	].
"if protected check that is a relative" protectionLevel = 'protected' ifTrue: [	(classWhoSentTheMessage inheritsFrom: OOPObject ) 		ifTrue: [			((classWhoSentTheMessage multInheritsFrom:  self class) or: (self class ==classWhoSentTheMessage )) 				ifTrue:[					"run method"					(self definingInstance: aSymbol) perform: aSymbol.					^self				]				]]."if private check that sender is directly under where method is, aka is exaclty this class "protectionLevel = 'private' ifTrue: [	(classWhoSentTheMessage == self class) ifTrue:[			"run method"			(self definingInstance: aSymbol) perform: aSymbol.			^self		]	]."else continue to throw the error message"self class throwSender: classWhoSentTheMessage name fails: aSymbolinClass: (self class name) because: protectionLevel.! !!OOPObject methodsFor: 'as yet unclassified' stamp: 'n 6/17/2018 17:48'!"basically a function that goes through the instances array , compare it to a given class , if it is it's instance it returns the instance , if not it continue to search first through the instances of the anccestors then the instances of the brothers"findInstance: aClass|tmp|tmp:=nil.(aClass ==nil)ifTrue:[^nil].self superclassInstances do: [:instance | (instance isMemberOf: aClass)	 ifTrue:[^instance] 	ifFalse:[		 ((instance class) inheritsFrom: OOPObject)		ifTrue:[tmp:= instance findInstance: aClass]		ifFalse:[tmp:= aClass new.]		].			(tmp==nil)ifFalse:[^tmp] ]. ^nil.! !!OOPObject methodsFor: 'as yet unclassified' stamp: 'n 6/12/2018 21:39'!initialize     ^self initializeSupers postInitialize ! !!OOPObject methodsFor: 'as yet unclassified' stamp: 'bw 6/16/2018 20:21'!initializeSupers|tmp|tmp := OrderedCollection new.((self class) superclasses) do: [ :currentSuper  | tmp addLast: ((currentSuper parentClass) new) ].superclassInstances:= tmp copy.! !!OOPObject methodsFor: 'as yet unclassified' stamp: 'n 6/12/2018 21:39'!postInitialize     ^self ! !!OOPObject methodsFor: 'as yet unclassified' stamp: 'n 6/14/2018 11:11'!superclassInstances	^superclassInstances.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OOPObject class	instanceVariableNames: 'superclasses'!!OOPObject class methodsFor: 'methods' stamp: 'n 6/16/2018 22:44'!classifyInheritedMethod: aSymbol|counter|"finds the access level of given aSymbol in relation to current class"counter :=self isAmbiguos: aSymbol."will count the number of appearences of aSymbol, reguardless of protection levels"( counter > 1) ifTrue:[ ^'ambiguous']. "if it does not even appear we can know already that it is undefined"(counter == 0) ifTrue:[ ^'undefined']."----------here we know that there is only ONE instance of the method---------""we return inaccsible if one of the father  anccestors has private in the way for the look up for the method "(self isInaccessible: aSymbol) ifTrue:[ ^'inaccessible']."we will only return private if the layer above is private"(self isPrivate: aSymbol) ifTrue:[ ^'private']."we try to find a path with ONLY public"(self isPublic: aSymbol) ifTrue:[ ^'public']."we try to find a path with only public AND protected"(self isProtected: aSymbol) ifTrue:[ ^'protected']."if we reach here shit gone wrong"^'error'! !!OOPObject class methodsFor: 'methods' stamp: 'bw 6/18/2018 12:48'!multInheritsFrom: aClass |flag|flag:=false.	(self superclasses) do: [ :parent |		 (((parent parentClass) == aClass) or: ((parent parentClass) inheritsFrom: aClass))			 	ifTrue:[ ^true]		 ifFalse:[			((parent parentClass) isKindOf: (OOPObject class)) 			ifTrue:[flag:=(((parent parentClass)) multInheritsFrom: aClass) .							]			].		(flag==true)				ifTrue:[^true]		].^false.! !!OOPObject class methodsFor: 'methods' stamp: 'n 6/13/2018 15:12'!subclass: aSubclassName instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionaries category: aCategoryName | supperClassesArray |supperClassesArray := OrderedCollection new.self subclass: aSubclassName parentClasses:supperClassesArray instanceVariableNames: instVarNames classVariableNames:classVarNames poolDictionaries: poolDictionaries category: aCategoryName.! !!OOPObject class methodsFor: 'methods' stamp: 'bw 6/16/2018 20:40'!subclass: aSubclassName parentClasses: anArray instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionaries category: aCategoryName	|newInstance tmp array|array := OrderedCollection  new.	"If Object doesn't inhert directly from OOPObject"(self ==OOPObject) ifFalse:[	"we make new OOPparent object that contains the original father "	tmp :=  OOPParent new. 	tmp parentClass: (self ).	array  addFirst: tmp.].anArray do: [:givenSuperClasses |  array addLast: givenSuperClasses].	newInstance :=(ClassBuilder new)		superclass: OOPObject		subclass: aSubclassName		instanceVariableNames: instVarNames		classVariableNames: classVarNames		poolDictionaries: poolDictionaries		category: aCategoryName.		newInstance instVarNamed: #superclasses put: (array asArray).^newInstance.! !!OOPObject class methodsFor: 'initialize-release' stamp: 'n 6/12/2018 21:55'!superclasses	^superclasses.! !!OOPObject class methodsFor: 'as yet unclassified' stamp: 'n 6/17/2018 17:37'!findClassThatContains: aSymbol|tmp|tmp:=nil.self  superclasses do: [:father | (((father parentClass) selectors) includes: aSymbol) 	ifTrue:[^(father parentClass).] 	 ifFalse:[		((father parentClass) inheritsFrom: OOPObject)		ifTrue:[					tmp:=(father parentClass) findClassThatContains: aSymbol.									]		ifFalse:[								tmp:= (father parentClass)  whichClassIncludesSelector: aSymbol.									]				. 			].			(tmp==nil) ifFalse:[^tmp].			].^nil.! !!OOPObject class methodsFor: 'as yet unclassified' stamp: 'n 6/17/2018 16:51'!isAmbiguos: aSymbol | counter fatherAmbg|fatherAmbg :=0.counter :=0."go over all fathers and search for the method" (self superclasses) do: [:father | (((father parentClass) selectors) includes: aSymbol) 	 ifTrue:[ counter := counter + 1.]	 ifFalse:[ 		((father parentClass) inheritsFrom: OOPObject) 			ifTrue:[					fatherAmbg := (father parentClass) isAmbiguos: aSymbol.									counter := counter + ((father parentClass) isAmbiguos: aSymbol) .			]			ifFalse:[				((father parentClass) canUnderstand: aSymbol) 					ifTrue: [counter := counter + 1].			]	].		((father parentClass) inheritsFrom: OOPObject) 			ifTrue:[					fatherAmbg := (father parentClass) isAmbiguos: aSymbol.				].			(fatherAmbg > counter ) ifTrue:[ counter:=fatherAmbg . ].					].^counter! !!OOPObject class methodsFor: 'as yet unclassified' stamp: 'n 6/16/2018 18:20'!isByProtectionLevel: aSymbol | flag|flag :=false."again , OOPObject is not in the array thus never gonna be called with this methods , and squeak sees everyone that implement multiply inhertence as direct son of OOPObject , we only look at the array which does not contain OOPObject. ""if OOPObject reached stop recursion(name = 'OOPObject') ifTrue: [	(((self parentClass) selectors) includes: aSymbol) 		ifTrue:[^true]		ifFalse:[^false]		]..""go over all fathers and search for the method" self superclasses do: [:father | (father inheritanceType = 'public' )	 ifTrue:[		(((father parentClass) selectors) includes: aSymbol) 		ifTrue:[^true]		ifFalse:[ flag:=(father parentClass) isPublic: aSymbol.				(flag==true)				ifTrue:[^true]				]			]		].	^false.! !!OOPObject class methodsFor: 'as yet unclassified' stamp: 'n 6/17/2018 16:08'!isInaccessible: aSymbol " self superclasses: [:superClass | 	(superClass parentClass) classCanUnderstand: aSymbol ]TODO - should this be re-written? , yes ""we check for each father if he has anccestor with private inhertance with that method  )"self superclasses do: [:father |	(((father parentClass) selectors) includes: aSymbol) 		ifTrue:[^false].	((father parentClass) inheritsFrom: OOPObject)	ifTrue:[			((father parentClass) isPrivate: aSymbol) 			ifTrue:[^true]			ifFalse:[^((father parentClass) isInaccessible: aSymbol)]		] 	].^false.		! !!OOPObject class methodsFor: 'as yet unclassified' stamp: 'n 6/17/2018 16:21'!isPrivate: aSymbol "checks ONLY first level above for the method with private access""go over all fathers and search for the method" self superclasses do: [:father | (father inheritanceType = 'private' )	 ifTrue:[ 			(((father parentClass) selectors) includes: aSymbol) 			ifTrue:[^true].					((father parentClass) inheritsFrom: OOPObject)			ifTrue:[				((father parentClass) isProtected: aSymbol)				ifTrue:[						^true.					]								]			ifFalse:[((father parentClass) canUnderstand:  aSymbol)				ifTrue:[					^true.					].				].			].	].^false.! !!OOPObject class methodsFor: 'as yet unclassified' stamp: 'n 6/17/2018 16:21'!isProtected: aSymbol | flag|flag :=false."if OOPObject reached stop recursion.(name = 'OOPObject') ifTrue: [	(((self parentClass) selectors) includes: aSymbol) 		ifTrue:[^true]		ifFalse:[^false]		].""go over all fathers and search for the method" self superclasses do: [:father | ((father inheritanceType = 'public') or: (father inheritanceType = 'protected') )	 ifTrue:[		(((father parentClass) selectors) includes: aSymbol) 		ifTrue:[^true]		ifFalse:[ 			((father parentClass) inheritsFrom: OOPObject )			ifTrue:[						flag:=(father parentClass) isProtected: aSymbol.				]			ifFalse:[										flag:=(father parentClass) canUnderstand:  aSymbol.				]									]		].		(flag==true)		ifTrue:[^true]		].	^false.		! !!OOPObject class methodsFor: 'as yet unclassified' stamp: 'n 6/17/2018 16:21'!isPublic: aSymbol | flag|flag :=false."nein nein nein nein""if OOPObject reached stop recursion.""(name = 'OOPObject') ifTrue: [	(((self parentClass) selectors) includes: aSymbol) 		ifTrue:[^true]		ifFalse:[^false]		].""go over all fathers and search for the method" self superclasses do: [:father | (father inheritanceType = 'public' )	 ifTrue:[		(((father parentClass) selectors) includes: aSymbol) 		ifTrue:[^true]		ifFalse:[			((father parentClass) inheritsFrom: OOPObject )			ifTrue:[						flag:=(father parentClass) isPublic: aSymbol.				]			ifFalse:[										flag:=(father parentClass) canUnderstand:  aSymbol.					]										]			].			(flag==true)			ifTrue:[^true].									].	^false.! !!OOPObject class methodsFor: 'as yet unclassified' stamp: 'n 6/14/2018 11:40'!throwSender: senderName fails: methodName inClass: receiverName because: reason | str |     str := senderName, ' cannot send ',methodName asString,' to ',receiverName,' because: ' ,reason.     AssertionFailure signal: str.! !Object subclass: #OOPParent	instanceVariableNames: 'parentClass inheritanceType'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP4'!!OOPParent methodsFor: 'initialize-release' stamp: 'n 6/16/2018 18:19'!initialize	parentClass :=Object.	inheritanceType :='public'.! !!OOPParent methodsFor: 'methods' stamp: 'bw 6/6/2018 14:59'!inheritanceType	"returns inheritanceType"	^inheritanceType! !!OOPParent methodsFor: 'methods' stamp: 'n 6/16/2018 18:19'!inheritanceType: aString	"set inheritanceType"	 (aString isString) ifTrue: [inheritanceType := aString]				         ifFalse: [self error: 'invalid string input']! !!OOPParent methodsFor: 'methods' stamp: 'bw 6/6/2018 14:58'!parentClass	"returns parentClass"	^parentClass! !!OOPParent methodsFor: 'methods' stamp: 'n 6/16/2018 18:19'!parentClass: aClass	"sets parentClass"	parentClass := aClass! !